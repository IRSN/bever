
## ***********************************************************************
##' Density, distribution function, quantile function and random
##' generation for the two-parameter Generalized Pareto Distibution
##' (GPD) distribution with \code{scale} and \code{shape}.
##'
##' @name GPD2
##' @rdname GPD2
##' 
##' @title Density, Distribution Function, Quantile Function and
##' Random Generation for the Two-Parameter Generalized Pareto
##' Distribution (GPD)
##' 
##' @param scale Scale parameter. Numeric vector with suitable length,
##' see \bold{Details}.
##'
##' @param shape Shape parameter. Numeric vector with suitable length,
##' see \bold{Details}.
##'
##' @param log Logical; if \code{TRUE}, densities \code{p} are
##' returned as \code{log(p)}.
##' 
##' @param deriv Logical. If \code{TRUE}, the gradient of each
##' computed value w.r.t. the parameter vector is computed, and
##' returned as a \code{"gradient"} attribute of the result. This is a
##' numeric array with dimension \code{c(n, 2)} where \code{n} is the
##' length of the first argument, i.e. \code{x}, \code{p} or \code{q},
##' depending on the function.
##'
##' @param hessian Logical. If \code{TRUE}, the Hessian of each
##' computed value w.r.t. the parameter vector is computed, and
##' returned as a \code{"hessian"} attribute of the result. This is a
##' numeric array with dimension \code{c(n, 2, 2)} where \code{n} is
##' the length of the first argument, i.e. \code{x}, \code{p} or
##' depending on the function. 
##'
##' @param x,q Vector of quantiles.
##'
##' @param p Vector of probabilities.
##'
##' @param n Sample size.
##' 
##' @param lower.tail Logical; if \code{TRUE} (default), probabilities are
##' P[X <= x], otherwise, P[X > x].
##'
##' @return A numeric vector with length equal to the length of the
##' first argument or of the parameters. When \code{deriv} is
##' \code{TRUE}, the returned value has an attribute named
##' \code{"gradient"} which is a matrix with \eqn{n} lines and \eqn{2}
##' columns containing the derivatives. A row contains the partial
##' derivatives of the corresponding element w.r.t. the three
##' parameters \code{loc} \code{scale} and \code{shape} in that order.
##'
##' @details For the \code{d}, \code{p} and \code{q} functions, let
##' \code{n} be the length of the first element. If \code{n > 1}, then
##' each of the parameters \code{loc}, \code{scale} and \code{shape}
##' must be of length \code{1} or \code{n}: in the first case, it will
##' be recycled to have length \code{n}. When \code{n = 1} the largest
##' length met for the three parameters, say \code{np} is used. The
##' two other parameters must then be of length \code{1} or \code{np},
##' and are given the length \code{np}, as well as the first argument.
##' Note that only vectors of length one are actually recycled.
##'
##' @note The attribues \code{"gradient"} and \code{"hessian"} have
##' dimension \code{c(n, 2)} and \code{c(n, 2, 2} even when \code{n}
##' equals \code{1}. Use the \code{drop} method on these object to
##' drop the extra dimension if wanted i.e. to get a gradient vector
##' and a Hessian matrix.
##' 
##' @author Yves Deville
##'
dGPD2 <- function(x, scale = 1.0, shape = 0.0, log = FALSE,
                  deriv = FALSE, hessian = FALSE) {

    if (hessian && !deriv) {
        stop("'hessian' can be TRUE only when 'gradient' is TRUE")
    }
    
    res <- .Call(Call_dGPD2,
                 as.double(x),
                 as.double(scale),
                 as.double(shape),
                 as.integer(log),
                 as.integer(deriv),
                 as.integer(hessian))
    
    n <- length(res)
    if (deriv) {
        nm2 <- c("scale", "shape")
        attr(res, "gradient") <-
            array(attr(res, "gradient"),
                  dim = c(n, 2L),
                  dimnames = list(rownames(x), nm2))
        
        if (hessian) {
            attr(res, "hessian") <-
                array(attr(res, "hessian"),
                      dim = c(n, 2L, 2L),
                      dimnames = list(rownames(x), nm2, nm2))
        }
        
    }

    return(res)
    
}

##' @rdname GPD2
pGPD2 <- function (q, scale = 1.0, shape = 0, lower.tail = TRUE,
                   deriv = FALSE, hessian = FALSE) {
    
    if (hessian && !deriv) {
        stop("'hessian' can be TRUE only when 'gradient' is TRUE")
    }

    res <- .Call(Call_pGPD2,
                 as.double(q),
                 as.double(scale),
                 as.double(shape),
                 as.integer(lower.tail),
                 as.integer(deriv),
                 as.integer(hessian))
    
    n <- length(res)
    if (deriv) {
        nm2 <- c("scale", "shape")
        attr(res, "gradient") <-
            array(attr(res, "gradient"),
                  dim = c(n, 2L),
                  dimnames = list(rownames(q), c("scale", "shape")))
        if (hessian) {
            attr(res, "hessian") <-
                array(attr(res, "hessian"),
                      dim = c(n, 2L, 2L),
                      dimnames = list(rownames(q), nm2, nm2))
        }
    }
    return(res)
    
}

##' @rdname GPD2
qGPD2 <- function (p, scale = 1.0, shape = 0.0, lower.tail = TRUE,
                   deriv = FALSE, hessian = FALSE) {
    
    if (hessian && !deriv) {
        stop("'hessian' can be TRUE only when 'gradient' is TRUE")
    }
    
    if (min(p, na.rm = TRUE) < 0.0 || max(p, na.rm = TRUE) > 1.0) 
        stop("`p' must contain probabilities in [0, 1]")
    
    res <- .Call(Call_qGPD2,
                 as.double(p),
                 as.double(scale),
                 as.double(shape),
                 as.integer(lower.tail),
                 as.integer(deriv),
                 as.integer(hessian))
    
    n <- length(res)
    if (deriv) {
        nm2 <- c("scale", "shape")
        attr(res, "gradient") <-
            array(attr(res, "gradient"),
                  dim = c(n, 2L),
                  dimnames = list(rownames(p), nm2))
        
        if (hessian) {
            attr(res, "hessian") <-
                array(attr(res, "hessian"),
                      dim = c(n, 2L, 2L),
                      dimnames = list(rownames(p), nm2, nm2))
        }
    }
    return(res)   

}

##' @rdname GPD2
rGPD2 <- function (n, scale = 1.0, shape = 0.0) {
    
    if (any(is.na(scale)) || any(scale <= 0) || !all(is.finite(scale))) {
        stop("'scale' must contain non-NA finite and positive numeric values")  
    }
    if (any(is.na(shape)) || !all(is.finite(shape))) {
        stop("'shape' must contain non-NA finite numeric values")  
    }

    pGPD2(runif(n), scale = scale, shape = shape)
    
}

